import { M as MediaProviderLoader, A as AudioProvider, a as MediaSrc, b as MediaType, V as VideoProvider, c as MediaContext, H as HLSProvider, T as Thumbnail, S as SliderOrientation, d as TextRenderer, e as TextTrack, f as TextTrackList, g as MediaKeyShortcuts } from './dist/types/vidstack-28971d92.js';
export { c0 as AnyMediaProvider, eR as AudioRadioGroup, eV as AudioRadioGroupChangeEvent, eT as AudioRadioGroupEvents, eS as AudioRadioGroupProps, eU as AudioRadioOption, bG as AudioTrack, bJ as AudioTrackAddEvent, bL as AudioTrackChangeEvent, bF as AudioTrackList, bI as AudioTrackListEvent, bH as AudioTrackListEvents, bK as AudioTrackRemoveEvent, dC as CaptionButton, dB as CaptionButtonProps, fh as Captions, fg as CaptionsProps, eW as CaptionsRadioGroup, e_ as CaptionsRadioGroupChangeEvent, eY as CaptionsRadioGroupEvents, eX as CaptionsRadioGroupProps, eZ as CaptionsRadioOption, bM as ChangeAudioTrackEventDetail, eN as ChapterRadioGroupProps, eM as ChaptersRadioGroup, eP as ChaptersRadioGroupChangeEvent, eO as ChaptersRadioGroupEvents, eQ as ChaptersRadioOption, dj as Controls, dm as ControlsChangeEvent, dl as ControlsEvents, dn as ControlsGroup, dk as ControlsProps, d7 as DefaultAudioLayout, d6 as DefaultLayout, db as DefaultLayoutContext, d9 as DefaultLayoutProps, da as DefaultLayoutTranslations, d8 as DefaultVideoLayout, bl as FindMediaPlayerEvent, bk as FindMediaPlayerEventDetail, o as FullscreenAdapter, dE as FullscreenButton, dD as FullscreenButtonProps, q as FullscreenChangeEvent, F as FullscreenController, r as FullscreenErrorEvent, p as FullscreenEvents, f8 as Gesture, fb as GestureAction, fd as GestureEvent, fa as GestureEventType, fc as GestureEvents, f9 as GestureProps, ff as GestureTriggerEvent, fe as GestureWillTriggerEvent, cD as HLSAudioTrackLoadedEvent, cC as HLSAudioTrackLoadingEvent, cB as HLSAudioTrackSwitchedEvent, cA as HLSAudioTrackSwitchingEvent, cz as HLSAudioTracksUpdatedEvent, d1 as HLSBackBufferReachedEvent, cl as HLSBufferAppendedEvent, ck as HLSBufferAppendingEvent, ci as HLSBufferCodecsEvent, cj as HLSBufferCreatedEvent, cm as HLSBufferEosEvent, co as HLSBufferFlushedEvent, cn as HLSBufferFlushingEvent, ch as HLSBufferResetEvent, d2 as HLSConstructor, d3 as HLSConstructorLoader, cK as HLSCuesParsedEvent, c_ as HLSDestroyingEvent, cZ as HLSErrorEvent, cX as HLSFpsDropEvent, cY as HLSFpsDropLevelCappingEvent, cV as HLSFragBufferedDataEvent, cW as HLSFragChangedEvent, cQ as HLSFragDecryptedEvent, cO as HLSFragLoadEmergencyAbortedEvent, cP as HLSFragLoadedEvent, cN as HLSFragLoadingEvent, cU as HLSFragParsedEvent, cR as HLSFragParsingInitSegmentEvent, cT as HLSFragParsingMetadataEvent, cS as HLSFragParsingUserdataEvent, cM as HLSInitPtsFoundEvent, d5 as HLSInstanceCallback, cb as HLSInstanceEvent, d0 as HLSKeyLoadedEvent, c$ as HLSKeyLoadingEvent, cv as HLSLevelLoadedEvent, cu as HLSLevelLoadingEvent, cx as HLSLevelPtsUpdatedEvent, ct as HLSLevelSwitchedEvent, cs as HLSLevelSwitchingEvent, cw as HLSLevelUpdatedEvent, cy as HLSLevelsUpdatedEvent, ca as HLSLibLoadErrorEvent, c8 as HLSLibLoadStartEvent, c9 as HLSLibLoadedEvent, d4 as HLSLibrary, cq as HLSManifestLoadedEvent, cp as HLSManifestLoadingEvent, cr as HLSManifestParsedEvent, ce as HLSMediaAttachedEvent, cd as HLSMediaAttachingEvent, cg as HLSMediaDetachedEvent, cf as HLSMediaDetachingEvent, c7 as HLSMediaEvent, cL as HLSNonNativeTextTracksFoundEvent, c6 as HLSProviderEvents, cJ as HLSSubtitleFragProcessedEvent, cI as HLSSubtitleTrackLoadedEvent, cH as HLSSubtitleTrackLoadingEvent, cG as HLSSubtitleTrackSwitchEvent, cF as HLSSubtitleTracksClearedEvent, cE as HLSSubtitleTracksUpdatedEvent, cc as HLSUnsupportedEvent, i as List, k as ListAddEvent, j as ListEvents, h as ListItem, m as ListReadonlyChangeEvent, l as ListRemoveEvent, dM as LiveButton, dL as LiveButtonProps, u as LogEvent, t as LogEventDetail, L as Logger, s as LoggerEvents, O as MediaAbortEvent, Q as MediaAudioTrackChangeEvent, aR as MediaAudioTrackChangeRequestEvent, P as MediaAudioTracksChangeEvent, R as MediaAutoplayChangeEvent, W as MediaAutoplayEvent, U as MediaAutoplayFailEvent, X as MediaCanLoadEvent, Z as MediaCanPlayDetail, Y as MediaCanPlayEvent, _ as MediaCanPlayThroughEvent, J as MediaControls, $ as MediaControlsChangeEvent, a2 as MediaDestroyEvent, a3 as MediaDurationChangeEvent, a4 as MediaEmptiedEvent, a5 as MediaEndEvent, a6 as MediaEndedEvent, aS as MediaEnterFullscreenRequestEvent, aU as MediaEnterPIPRequestEvent, ba as MediaErrorCode, bb as MediaErrorDetail, a7 as MediaErrorEvent, N as MediaEvent, K as MediaEvents, aT as MediaExitFullscreenRequestEvent, aV as MediaExitPIPRequestEvent, c3 as MediaFullscreenAdapter, a8 as MediaFullscreenChangeEvent, a9 as MediaFullscreenErrorEvent, aQ as MediaFullscreenRequestTarget, b5 as MediaHidePosterRequestEvent, b_ as MediaKeyShortcut, bZ as MediaKeyTarget, b$ as MediaKeysCallback, ad as MediaLiveChangeEvent, ae as MediaLiveEdgeChangeEvent, aW as MediaLiveEdgeRequestEvent, af as MediaLoadStartEvent, aa as MediaLoadedDataEvent, ab as MediaLoadedMetadataEvent, b9 as MediaLoadingStrategy, ac as MediaLoopChangeEvent, b6 as MediaLoopRequestEvent, aO as MediaMuteRequestEvent, aB as MediaOrientationChangeEvent, ar as MediaPIPChangeEvent, as as MediaPIPErrorEvent, b3 as MediaPauseControlsRequestEvent, ah as MediaPauseEvent, a_ as MediaPauseRequestEvent, ai as MediaPlayEvent, aj as MediaPlayFailEvent, aX as MediaPlayRequestEvent, df as MediaPlayer, bj as MediaPlayerConnectEvent, G as MediaPlayerEvents, D as MediaPlayerProps, bd as MediaPlayerState, ak as MediaPlayingEvent, al as MediaPlaysinlineChangeEvent, am as MediaPosterChangeEvent, an as MediaProgressEvent, di as MediaProvider, c1 as MediaProviderAdapter, ap as MediaProviderChangeEvent, ao as MediaProviderLoaderChangeEvent, dg as MediaProviderProps, aq as MediaProviderSetupEvent, dh as MediaProviderState, at as MediaQualitiesChangeEvent, au as MediaQualityChangeEvent, aY as MediaQualityChangeRequestEvent, a0 as MediaRateChangeEvent, aZ as MediaRateChangeRequestEvent, I as MediaRemoteControl, aC as MediaReplayEvent, aL as MediaRequestEvents, bc as MediaResource, b2 as MediaResumeControlsRequestEvent, a$ as MediaSeekRequestEvent, av as MediaSeekedEvent, aw as MediaSeekingEvent, b0 as MediaSeekingRequestEvent, c2 as MediaSetupContext, b4 as MediaShowPosterRequestEvent, a1 as MediaSourceChangeEvent, ax as MediaSourcesChangeEvent, ay as MediaStalledEvent, aM as MediaStartLoadingRequestEvent, az as MediaStartedEvent, bi as MediaState, E as MediaStateAccessors, bg as MediaStore, b7 as MediaStreamType, aE as MediaStreamTypeChangeEvent, aA as MediaSuspendEvent, aG as MediaTextTrackChangeEvent, aN as MediaTextTrackChangeRequestEvent, aF as MediaTextTracksChangeEvent, aD as MediaTimeUpdateEvent, ag as MediaTypeChangeEvent, aP as MediaUnmuteRequestEvent, bm as MediaUserEvents, b8 as MediaViewType, aH as MediaViewTypeChangeEvent, aI as MediaVolumeChange, aJ as MediaVolumeChangeEvent, b1 as MediaVolumeChangeRequestEvent, aK as MediaWaitingEvent, ej as Menu, eo as MenuButton, eq as MenuButtonEvents, ep as MenuButtonProps, er as MenuButtonSelectEvent, en as MenuCloseEvent, el as MenuEvents, es as MenuItem, ex as MenuItems, eB as MenuItemsProps, em as MenuOpenEvent, ey as MenuPlacement, eA as MenuPlacementAlign, ez as MenuPlacementSide, et as MenuPortal, ev as MenuPortalContext, eu as MenuPortalProps, ek as MenuProps, dG as MuteButton, dF as MuteButtonProps, dI as PIPButton, dH as PIPButtonProps, dA as PlayButton, dz as PlayButtonProps, bN as PlayerQueryList, bP as PlayerQueryListChangeEvent, bO as PlayerQueryListEvents, bh as PlayerStore, fk as Poster, fi as PosterProps, fj as PosterState, f3 as QualityRadioGroup, f7 as QualityRadioGroupChangeEvent, f6 as QualityRadioGroupEvents, f4 as QualityRadioGroupProps, f5 as QualityRadioOption, eG as Radio, eJ as RadioChangeEvent, eI as RadioEvents, eC as RadioGroup, eF as RadioGroupChangeEvent, eE as RadioGroupEvents, eD as RadioGroupProps, eL as RadioOption, eH as RadioProps, eK as RadioSelectEvent, y as ScreenOrientationChangeEvent, x as ScreenOrientationChangeEventDetail, v as ScreenOrientationController, w as ScreenOrientationEvents, B as ScreenOrientationLockType, z as ScreenOrientationType, dK as SeekButton, dJ as SeekButtonProps, dY as Slider, dU as SliderCSSVars, eh as SliderChapters, ei as SliderChaptersProps, d$ as SliderController, e0 as SliderControllerProps, d_ as SliderDelegate, dQ as SliderDragEndEvent, dP as SliderDragStartEvent, dS as SliderDragValueChangeEvent, dO as SliderEvent, dN as SliderEvents, dT as SliderPointerValueChangeEvent, e9 as SliderPreview, eb as SliderPreviewProps, dZ as SliderProps, dX as SliderState, dW as SliderStore, e7 as SliderValue, dR as SliderValueChangeEvent, e8 as SliderValueProps, e1 as SliderVideo, e5 as SliderVideoCanPlayEvent, e6 as SliderVideoErrorEvent, e4 as SliderVideoEvents, e2 as SliderVideoProps, e3 as SliderVideoState, e$ as SpeedRadioGroup, f2 as SpeedRadioGroupChangeEvent, f1 as SpeedRadioGroupEvents, f0 as SpeedRadioGroupProps, bn as TextRenderers, bv as TextTrackAddCueEvent, bC as TextTrackAddEvent, bx as TextTrackCueChangeEvent, bu as TextTrackErrorEvent, br as TextTrackEvent, bq as TextTrackEvents, bp as TextTrackInit, bB as TextTrackListEvent, bA as TextTrackListEvents, bE as TextTrackListModeChangeEvent, bt as TextTrackLoadEvent, bs as TextTrackLoadStartEvent, by as TextTrackModeChangeEvent, bo as TextTrackReadyState, bw as TextTrackRemoveCueEvent, bD as TextTrackRemoveEvent, fq as ThumbnailCoords, fp as ThumbnailProps, fo as ThumbnailState, fr as ThumbnailsLoader, fl as Time, fm as TimeProps, ee as TimeSlider, ef as TimeSliderCSSVars, eg as TimeSliderProps, fn as TimeState, dy as ToggleButton, dx as ToggleButtonProps, dp as Tooltip, ds as TooltipContent, dw as TooltipContentProps, dt as TooltipPlacement, dv as TooltipPlacementAlign, du as TooltipPlacementSide, dq as TooltipProps, dr as TooltipTrigger, c5 as VideoPresentationChangeEvent, c4 as VideoPresentationEvents, bR as VideoQuality, bU as VideoQualityAddEvent, bY as VideoQualityAutoChangeEvent, bW as VideoQualityChangeEvent, bX as VideoQualityChangeEventDetail, bQ as VideoQualityList, bT as VideoQualityListEvent, bS as VideoQualityListEvents, bV as VideoQualityRemoveEvent, ed as VolumeSlider, ec as VolumeSliderProps, n as canFullscreen, dc as defaultLayoutContext, dd as getDefaultLayoutLang, bz as isTrackCaptionKind, C as mediaContext, be as mediaState, ew as menuPortalContext, dV as sliderState, bf as softResetMediaState, ea as updateSliderPreviewPlacement, de as useDefaultLayoutContext } from './dist/types/vidstack-28971d92.js';
import { R as ReadSignal, W as WriteSignal, C as Context, E as EventsTarget, D as Dispose, V as ViewController } from './dist/types/vidstack-b17407b1.js';
export { a as appendTriggerEvent, f as findTriggerEvent, h as hasTriggerEvent, b as isKeyboardClick, c as isKeyboardEvent, i as isPointerEvent, w as walkTriggerEventChain } from './dist/types/vidstack-b17407b1.js';
import { VTTCue } from 'media-captions';
export { IconProps } from './icons.js';
import 'hls.js';
import 'media-icons';

declare class AudioProviderLoader implements MediaProviderLoader<AudioProvider> {
    target: HTMLAudioElement;
    canPlay({ src, type }: MediaSrc): boolean;
    mediaType(): MediaType;
    load(): Promise<AudioProvider>;
}

declare class VideoProviderLoader implements MediaProviderLoader<VideoProvider> {
    target: HTMLVideoElement;
    canPlay(src: MediaSrc): boolean;
    mediaType(): MediaType;
    load(context: MediaContext): Promise<VideoProvider>;
}

declare class HLSProviderLoader extends VideoProviderLoader implements MediaProviderLoader<HLSProvider> {
    static supported: boolean;
    preconnect(): void;
    canPlay(src: MediaSrc): boolean;
    load(context: any): Promise<HLSProvider>;
}

/** @see {@link https://www.vidstack.io/docs/player/providers/audio} */
declare function isAudioProvider(provider: any): provider is AudioProvider;
/** @see {@link https://www.vidstack.io/docs/player/providers/video} */
declare function isVideoProvider(provider: any): provider is VideoProvider;
/** @see {@link https://www.vidstack.io/docs/player/providers/hls} */
declare function isHLSProvider(provider: any): provider is HLSProvider;
/** @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement} */
declare function isHTMLAudioElement(element: unknown): element is HTMLAudioElement;
/** @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement} */
declare function isHTMLVideoElement(element: unknown): element is HTMLVideoElement;
/** @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement} */
declare function isHTMLMediaElement(element: unknown): element is HTMLMediaElement;

/**
 * Used to display preview thumbnails when the user is hovering or dragging the time slider.
 * The time ranges in the WebVTT file will automatically be matched based on the current slider
 * pointer position.
 *
 * @attr data-loading - Whether thumbnail image is loading.
 * @attr data-error - Whether an error occurred loading thumbnail.
 * @attr data-hidden - Whether thumbnail is not available or failed to load.
 * @docs {@link https://www.vidstack.io/docs/player/components/sliders/slider-thumbnail}
 */
declare class SliderThumbnail extends Thumbnail {
    private _slider;
    protected onAttach(el: HTMLElement): void;
    protected _getTime(): number;
}

interface SliderContext {
    _disabled: ReadSignal<boolean>;
    _orientation: ReadSignal<SliderOrientation>;
    _preview: WriteSignal<HTMLElement | null>;
}
declare const sliderContext: Context<SliderContext>;

declare class TimeRange implements TimeRanges {
    private readonly _ranges;
    get length(): number;
    constructor(start?: number | [number, number][], end?: number);
    start(index: number): number;
    end(index: number): number;
}
declare function getTimeRangesStart(range: TimeRanges): number | null;
declare function getTimeRangesEnd(range: TimeRanges): number | null;

declare class LibASSTextRenderer implements TextRenderer {
    readonly loader: LibASSModuleLoader;
    config?: LibASSConfig | undefined;
    readonly priority = 1;
    private _instance;
    private _track;
    private _typeRE;
    constructor(loader: LibASSModuleLoader, config?: LibASSConfig | undefined);
    canRender(track: TextTrack): boolean;
    attach(video: HTMLVideoElement): void;
    changeTrack(track: TextTrack | null): void;
    detach(): void;
    private _freeTrack;
}
interface LibASSModuleLoader {
    (): Promise<{
        default: LibASSConstructor;
    }>;
}
interface LibASSConstructor {
    new (config?: {
        video: HTMLVideoElement;
        canvas?: HTMLCanvasElement;
        subUrl?: string;
    } & LibASSConfig): LibASSInstance;
}
interface LibASSInstance extends EventsTarget<LibASSInstanceEvents> {
    _video: HTMLVideoElement;
    _canvas: HTMLVideoElement | null;
    setTrackByUrl(url: string): void;
    setCurrentTime(time: number): void;
    freeTrack(): void;
    destroy(): void;
}
interface LibASSInstanceEvents {
    ready: LibASSReadyEvent;
    error: LibASSErrorEvent;
}
interface LibASSReadyEvent extends Event {
}
interface LibASSErrorEvent extends ErrorEvent {
}
/**
 * @see {@link https://github.com/ThaUnknown/jassub/tree/main#options}
 */
interface LibASSConfig {
    /**
     * Which image blending mode to use. WASM will perform better on lower end devices, JS will
     * perform better if the device and browser supports hardware acceleration.
     *
     * @defaultValue "js"
     */
    blendMode?: 'js' | 'wasm';
    /**
     * Whether or not to use async rendering, which offloads the CPU by creating image bitmaps on
     * the GPU.
     *
     * @defaultValue true
     */
    asyncRender?: boolean;
    /**
     * Whether or not to render things fully on the worker, greatly reduces CPU usage.
     *
     * @defaultValue true
     */
    offscreenRender?: boolean;
    /**
     * Whether or not to render subtitles as the video player renders frames, rather than predicting
     * which frame the player is on using events.
     *
     * @defaultValue true
     */
    onDemandRender?: boolean;
    /**
     * Target FPS to render subtitles at. Ignored when onDemandRender is enabled.
     *
     * @defaultValue 24
     */
    targetFps?: number;
    /**
     * Subtitle time offset in seconds.
     *
     * @defaultValue 0
     */
    timeOffset?: number;
    /**
     * Whether or not to print debug information.
     *
     * @defaultValue false
     */
    debug?: boolean;
    /**
     * Scale down (< 1.0) the subtitles canvas to improve performance at the expense of quality, or
     * scale it up (> 1.0).
     *
     * @defaultValue 1.0
     */
    prescaleFactor?: number;
    /**
     * The height in pixels beyond which the subtitles canvas won't be pre-scaled.
     *
     * @defaultValue 1080
     */
    prescaleHeightLimit?: number;
    /**
     * The maximum rendering height in pixels of the subtitles canvas. Beyond this subtitles will
     * be up-scaled by the browser.
     *
     * @defaultValue 0
     */
    maxRenderHeight?: number;
    /**
     * Attempt to discard all animated tags. Enabling this may severely mangle complex subtitles
     * and should only be considered as an last ditch effort of uncertain success for hardware
     * otherwise incapable of displaying anything. Will not reliably work with manually edited or
     * allocated events.
     *
     * @defaultValue false
     */
    dropAllAnimations?: boolean;
    /**
     * The URL of the worker.
     *
     * @defaultValue "jassub-worker.js"
     */
    workerUrl?: string;
    /**
     * The URL of the legacy worker. Only loaded if the browser doesn't support WASM.
     *
     * @defaultValue "jassub-worker-legacy.js"
     */
    legacyWorkerUrl?: string;
    /**
     * The URL of the subtitle file to play.
     *
     */
    subUrl?: string;
    /**
     * The content of the subtitle file to play.
     *
     */
    subContent?: string;
    /**
     * An array of links or `Uint8Array` to the fonts used in the subtitle. If `Uint8Array` is used
     * the array is copied, not referenced. This forces all the fonts in this array to be loaded
     * by the renderer, regardless of if they are used.
     *
     */
    fonts?: string[] | Uint8Array[];
    /**
     * Object with all available fonts. Key is font family in lower case, value is link or
     * `Uint8Array`. These fonts are selectively loaded if detected as used in the current
     * subtitle track.
     *
     * @defaultValue {'liberation sans': './default.woff2'}}
     */
    availableFonts?: Record<string, string>;
    /**
     * The font family key of the fallback font in `availableFonts` to use if the other font
     * for the style is missing special glyphs or unicode.
     *
     * @defaultValue "liberation sans"
     */
    fallbackFont?: string;
    /**
     * If the Local Font Access API is enabled `[chrome://flags/#font-access]`, the library will
     * query for permissions to use local fonts and use them if any are missing. The permission can
     * be queried beforehand using `navigator.permissions.request({ name: 'local-fonts' })`.
     *
     * @defaultValue true
     */
    useLocalFonts?: boolean;
    /**
     * libass bitmap cache memory limit in MiB (approximate).
     */
    libassMemoryLimit?: number;
    /**
     * libass glyph cache memory limit in MiB (approximate).
     */
    libassGlyphLimit?: number;
}

declare function findActiveCue(cues: readonly VTTCue[], time: number): VTTCue | null;
declare function isCueActive(cue: VTTCue, time: number): boolean;
declare function observeActiveTextTrack(tracks: TextTrackList, kind: TextTrackKind | TextTrackKind[], onChange: (track: TextTrack | null) => void): Dispose;

declare const MEDIA_KEY_SHORTCUTS: MediaKeyShortcuts;

declare class ARIAKeyShortcuts extends ViewController {
    private _shortcut;
    constructor(_shortcut: string);
    protected onAttach(el: HTMLElement): void;
}

/**
 * Formats the given `duration` into a human readable form that can be displayed to the user.
 *
 * @param duration - The length of time to parse in seconds.
 * @param shouldPadHours - Whether to pad the hours to be length of 2.
 * @param shouldPadMinutes - Whether to pad the minutes to be length of 2.
 * @param shouldAlwaysShowHours - Whether to always show the hours unit.
 * @example `01:20 -> minutes:seconds`
 * @example `3:01:20 -> hours:minutes:seconds`
 * @example If `shouldPadHours` is `true` - `03:01:20`
 * @example If `shouldAlwaysShowHours` is `true` - `0:01:20`
 */
declare function formatTime(duration: number, shouldPadHours?: boolean | null, shouldPadMinutes?: boolean | null, shouldAlwaysShowHours?: boolean): string;
/**
 * Formats the given `duration` into human spoken form.
 *
 * @param duration - The length of time to parse in seconds.
 * @example `2 hour 3 min 4 sec`
 */
declare function formatSpokenTime(duration: number): string;

/**
 * Checks if the ScreenOrientation API is available.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
 */
declare function canOrientScreen(): boolean;
/**
 * Checks if the screen orientation can be changed.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
 */
declare function canRotateScreen(): boolean;
/**
 * Checks if the native HTML5 video player can play HLS.
 */
declare function canPlayHLSNatively(video?: HTMLVideoElement): boolean;
/**
 * Checks if the native HTML5 video player can enter picture-in-picture (PIP) mode when using
 * the Chrome browser.
 *
 * @see {@link https://developers.google.com/web/updates/2018/10/watch-video-using-picture-in-picture}
 */
declare function canUsePictureInPicture(video: HTMLVideoElement): boolean;
/**
 * Checks if the native HTML5 video player can use the presentation API in Safari.
 *
 * @see {@link https://developer.apple.com/documentation/webkitjs/htmlvideoelement/1631913-webkitpresentationmode}
 */
declare function canUseVideoPresentation(video: HTMLVideoElement): boolean;
declare function canChangeVolume(): Promise<boolean>;

export { ARIAKeyShortcuts, AudioProvider, AudioProviderLoader, HLSProvider, HLSProviderLoader, LibASSConfig, LibASSConstructor, LibASSErrorEvent, LibASSInstance, LibASSInstanceEvents, LibASSModuleLoader, LibASSReadyEvent, LibASSTextRenderer, MEDIA_KEY_SHORTCUTS, MediaContext, MediaKeyShortcuts, MediaProviderLoader, MediaSrc, MediaType, SliderContext, SliderOrientation, SliderThumbnail, TextRenderer, TextTrack, TextTrackList, Thumbnail, TimeRange, VideoProvider, VideoProviderLoader, canChangeVolume, canOrientScreen, canPlayHLSNatively, canRotateScreen, canUsePictureInPicture, canUseVideoPresentation, findActiveCue, formatSpokenTime, formatTime, getTimeRangesEnd, getTimeRangesStart, isAudioProvider, isCueActive, isHLSProvider, isHTMLAudioElement, isHTMLMediaElement, isHTMLVideoElement, isVideoProvider, observeActiveTextTrack, sliderContext };
