import { g as IS_SAFARI, h as isHLSSrc, j as getNumberOfDecimalPlaces, L as ListSymbol, k as isMediaStream } from './vidstack-1d3e68d6.js';
import { y as isUndefined, A as isNumber, B as useDisposalBin, e as effect, o as onDispose, l as listenEvent, D as DOMEvent, E as isNil, F as createScope, f as setAttribute, k as isString } from './vidstack-fd2ab5eb.js';

class RAFLoop {
  constructor(_callback) {
    this.qa = _callback;
  }
  ga() {
    if (!isUndefined(this.Mc))
      return;
    this.vh();
  }
  ha() {
    if (isNumber(this.Mc))
      window.cancelAnimationFrame(this.Mc);
    this.Mc = void 0;
  }
  vh() {
    this.Mc = window.requestAnimationFrame(() => {
      if (isUndefined(this.Mc))
        return;
      this.qa();
      this.vh();
    });
  }
}

class HTMLMediaEvents {
  constructor(_provider, _ctx) {
    this.ta = useDisposalBin();
    this.mg = false;
    this.og = false;
    this.pg = false;
    this.ng = new RAFLoop(this.tg.bind(this));
    this.sg = void 0;
    this.Mg = void 0;
    this.Ub = _provider;
    this.S = _ctx;
    this.ug();
    effect(this.vg.bind(this));
    onDispose(this.ya.bind(this));
  }
  get g() {
    return this.Ub.media;
  }
  get ld() {
    return this.S.delegate;
  }
  ya() {
    this.og = false;
    this.pg = false;
    this.ng.ha();
    this.ta.empty();
  }
  /**
   * The `timeupdate` event fires surprisingly infrequently during playback, meaning your progress
   * bar (or whatever else is synced to the currentTime) moves in a choppy fashion. This helps
   * resolve that by retrieving time updates in a request animation frame loop.
   */
  tg() {
    const newTime = this.Ub.currentTime;
    if (this.S.$state.currentTime() !== newTime)
      this.lg(newTime);
  }
  ug() {
    this.kg("loadstart", this.na);
    this.kg("abort", this.rg);
    this.kg("emptied", this.wg);
    this.kg("error", this.V);
  }
  xg() {
    if (this.og)
      return;
    this.ta.add(
      this.kg("loadeddata", this.yg),
      this.kg("loadedmetadata", this.zg),
      this.kg("canplay", this.xd),
      this.kg("canplaythrough", this.Ag),
      this.kg("durationchange", this.Bg),
      this.kg("play", this.Va),
      this.kg("progress", this.Cg),
      this.kg("stalled", this.Dg),
      this.kg("suspend", this.Eg)
    );
    this.og = true;
  }
  Fg() {
    if (this.pg)
      return;
    this.ta.add(
      this.kg("pause", this.Wa),
      this.kg("playing", this.Gg),
      this.kg("ratechange", this.Hg),
      this.kg("seeked", this.Ig),
      this.kg("seeking", this.Jg),
      this.kg("ended", this.Kg),
      this.kg("volumechange", this.Kd),
      this.kg("waiting", this.Lg)
    );
    this.pg = true;
  }
  kg(eventType, handler) {
    return listenEvent(
      this.g,
      eventType,
      handler.bind(this)
    );
  }
  Ng(event2) {
    return;
  }
  lg(time, trigger) {
    this.ld.f("time-update", {
      // Avoid errors where `currentTime` can have higher precision.
      detail: {
        currentTime: Math.min(time, this.S.$state.seekableEnd()),
        played: this.g.played
      },
      trigger
    });
  }
  na(event2) {
    if (this.g.networkState === 3) {
      this.rg(event2);
      return;
    }
    this.xg();
    this.ld.f("load-start", { trigger: event2 });
  }
  rg(event2) {
    this.ld.f("abort", { trigger: event2 });
  }
  wg() {
    this.ld.f("emptied", { trigger: event });
  }
  yg(event2) {
    this.ld.f("loaded-data", { trigger: event2 });
  }
  zg(event2) {
    this.Fg();
    this.ld.f("volume-change", {
      detail: {
        volume: this.g.volume,
        muted: this.g.muted
      }
    });
    this.ld.f("loaded-metadata", { trigger: event2 });
    if (IS_SAFARI && isHLSSrc(this.S.$state.source())) {
      this.ld.Og(this.qg(), event2);
    }
  }
  qg() {
    return {
      duration: this.g.duration,
      buffered: this.g.buffered,
      seekable: this.g.seekable
    };
  }
  Va(event2) {
    if (!this.S.$state.canPlay)
      return;
    this.ld.f("play", { trigger: event2 });
  }
  Wa(event2) {
    if (this.g.readyState === 1 && !this.mg)
      return;
    this.mg = false;
    this.ng.ha();
    this.ld.f("pause", { trigger: event2 });
  }
  xd(event2) {
    this.ld.Og(this.qg(), event2);
  }
  Ag(event2) {
    if (this.S.$state.started())
      return;
    this.ld.f("can-play-through", {
      trigger: event2,
      detail: this.qg()
    });
  }
  Gg(event2) {
    this.mg = false;
    this.ld.f("playing", { trigger: event2 });
    this.ng.ga();
  }
  Dg(event2) {
    this.ld.f("stalled", { trigger: event2 });
    if (this.g.readyState < 3) {
      this.mg = true;
      this.ld.f("waiting", { trigger: event2 });
    }
  }
  Lg(event2) {
    if (this.g.readyState < 3) {
      this.mg = true;
      this.ld.f("waiting", { trigger: event2 });
    }
  }
  Kg(event2) {
    this.ng.ha();
    this.lg(this.g.duration, event2);
    this.ld.f("end", { trigger: event2 });
    if (this.S.$state.loop()) {
      this.Pg();
    } else {
      this.ld.f("ended", { trigger: event2 });
    }
  }
  vg() {
    if (this.S.$state.paused()) {
      listenEvent(this.g, "timeupdate", this.Qg.bind(this));
    }
  }
  Qg(event2) {
    this.lg(this.g.currentTime, event2);
  }
  Bg(event2) {
    if (this.S.$state.ended()) {
      this.lg(this.g.duration, event2);
    }
    this.ld.f("duration-change", {
      detail: this.g.duration,
      trigger: event2
    });
  }
  Kd(event2) {
    this.ld.f("volume-change", {
      detail: {
        volume: this.g.volume,
        muted: this.g.muted
      },
      trigger: event2
    });
  }
  Ig(event2) {
    this.lg(this.g.currentTime, event2);
    this.ld.f("seeked", {
      detail: this.g.currentTime,
      trigger: event2
    });
    if (Math.trunc(this.g.currentTime) === Math.trunc(this.g.duration) && getNumberOfDecimalPlaces(this.g.duration) > getNumberOfDecimalPlaces(this.g.currentTime)) {
      this.lg(this.g.duration, event2);
      if (!this.g.ended) {
        this.S.player.dispatch(
          new DOMEvent("media-play-request", {
            trigger: event2
          })
        );
      }
    }
  }
  Jg(event2) {
    this.ld.f("seeking", {
      detail: this.g.currentTime,
      trigger: event2
    });
  }
  Cg(event2) {
    this.ld.f("progress", {
      detail: {
        buffered: this.g.buffered,
        seekable: this.g.seekable
      },
      trigger: event2
    });
  }
  Pg() {
    const hasCustomControls = isNil(this.g.controls);
    if (hasCustomControls)
      this.g.controls = false;
    this.S.player.dispatch(new DOMEvent("media-loop-request"));
  }
  Eg(event2) {
    this.ld.f("suspend", { trigger: event2 });
  }
  Hg(event2) {
    this.ld.f("rate-change", {
      detail: this.g.playbackRate,
      trigger: event2
    });
  }
  V(event2) {
    const error = this.g.error;
    if (!error)
      return;
    this.ld.f("error", {
      detail: {
        message: error.message,
        code: error.code,
        mediaError: error
      },
      trigger: event2
    });
  }
}

class NativeAudioTracks {
  constructor(_provider, _context) {
    this.Ub = _provider;
    this.wa = _context;
    this.Rg.onaddtrack = this.Tg.bind(this);
    this.Rg.onremovetrack = this.Ug.bind(this);
    this.Rg.onchange = this.Vg.bind(this);
    listenEvent(this.wa.audioTracks, "change", this.Wg.bind(this));
  }
  get Rg() {
    return this.Ub.media.audioTracks;
  }
  Tg(event) {
    const _track = event.track;
    if (_track.label === "")
      return;
    const audioTrack = {
      id: _track.id + "",
      label: _track.label,
      language: _track.language,
      kind: _track.kind,
      selected: false
    };
    this.wa.audioTracks[ListSymbol.r](audioTrack, event);
    if (_track.enabled)
      audioTrack.selected = true;
  }
  Ug(event) {
    const track = this.wa.audioTracks.getById(event.track.id);
    if (track)
      this.wa.audioTracks[ListSymbol.p](track, event);
  }
  Vg(event) {
    let enabledTrack = this.Sg();
    if (!enabledTrack)
      return;
    const track = this.wa.audioTracks.getById(enabledTrack.id);
    if (track)
      this.wa.audioTracks[ListSymbol.fa](track, true, event);
  }
  Sg() {
    return Array.from(this.Rg).find((track) => track.enabled);
  }
  Wg(event) {
    const { current } = event.detail;
    if (!current)
      return;
    const track = this.Rg.getTrackById(current.id);
    if (track) {
      const prev = this.Sg();
      if (prev)
        prev.enabled = false;
      track.enabled = true;
    }
  }
}

class HTMLMediaProvider {
  constructor(_media) {
    this.scope = createScope();
    this.h = null;
    this.g = _media;
  }
  setup(context) {
    new HTMLMediaEvents(this, context);
    if ("audioTracks" in this.media)
      new NativeAudioTracks(this, context);
    this.playsinline = context.$state.playsinline();
    onDispose(() => {
      this.g.setAttribute("src", "");
      this.g.load();
    });
  }
  get type() {
    return "";
  }
  get media() {
    return this.g;
  }
  get currentSrc() {
    return this.h;
  }
  get paused() {
    return this.g.paused;
  }
  get muted() {
    return this.g.muted;
  }
  set muted(muted) {
    this.g.muted = muted;
  }
  get volume() {
    return this.g.volume;
  }
  set volume(volume) {
    this.g.volume = volume;
  }
  get currentTime() {
    return this.g.currentTime;
  }
  set currentTime(time) {
    this.g.currentTime = time;
  }
  get playsinline() {
    return this.g.hasAttribute("playsinline");
  }
  set playsinline(playsinline) {
    setAttribute(this.g, "playsinline", playsinline);
  }
  get playbackRate() {
    return this.g.playbackRate;
  }
  set playbackRate(rate) {
    this.g.playbackRate = rate;
  }
  async play() {
    return this.g.play();
  }
  async pause() {
    return this.g.pause();
  }
  async loadSource({ src, type }, preload) {
    this.g.preload = preload || "";
    if (isMediaStream(src)) {
      this.g.srcObject = src;
    } else {
      this.g.srcObject = null;
      this.g.src = isString(src) ? src : window.URL.createObjectURL(src);
    }
    this.g.load();
    this.h = { src, type };
  }
}

export { HTMLMediaProvider as H, RAFLoop as R };
