import { h as signal, e as effect, p as peek, d as defineCustomElement } from '../chunks/vidstack-fd2ab5eb.js';
import { lazyPaths } from 'media-icons';
import { c as cloneTemplateContent, a as createTemplate } from '../chunks/vidstack-27a11379.js';

const svgTemplate = /* @__PURE__ */ createTemplate(
  `<svg width="100%" height="100%" viewBox="0 0 32 32" fill="none" aria-hidden="true" focusable="false" xmlns="http://www.w3.org/2000/svg"></svg>`
);
class MediaIconElement extends HTMLElement {
  constructor() {
    super(...arguments);
    this.ra = this.ua();
    this.sa = signal("");
    this.A = signal(null);
    this.ta = [];
  }
  static {
    this.tagName = "media-icon";
  }
  static get observedAttributes() {
    return ["type"];
  }
  /**
   * The type of icon. You can find a complete and searchable list on our website - see our
   * [media icons catalog](https://www.vidstack.io/media-icons?lib=html).
   */
  get type() {
    return this.A();
  }
  set type(type) {
    this.A.set(type);
    if (type)
      this.setAttribute("type", type);
    else
      this.removeAttribute("type");
  }
  attributeChangedCallback(name, _, newValue) {
    if (name === "type") {
      this.A.set(newValue ? newValue : null);
    }
  }
  connectedCallback() {
    this.classList.add("vds-icon");
    if (this.ra.parentNode !== this) {
      this.prepend(this.ra);
    }
    this.ta.push(
      // Load
      effect(this.va.bind(this)),
      // Render
      effect(() => {
        this.ra.innerHTML = this.sa();
      })
    );
  }
  disconnectedCallback() {
    for (const fn of this.ta)
      fn();
    this.ta.length = 0;
  }
  ua() {
    return cloneTemplateContent(svgTemplate);
  }
  va() {
    const type = this.A();
    if (type && lazyPaths[type]) {
      lazyPaths[type]().then(({ default: paths }) => {
        if (type === peek(this.A))
          this.sa.set(paths);
      });
    } else {
      this.sa.set("");
    }
  }
}

defineCustomElement(MediaIconElement);
